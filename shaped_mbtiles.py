"""
Shaped MBTiles Generator - CLIPPING VERSION

This version uses QPainter clipping instead of filling the inverse.
The idea is to clip rendering to only the polygon area, which should be more efficient.

Compare with shaped_mbtiles.py (fills inverse) to see which works better for your use case.
"""

import os
import math
import sqlite3
from io import BytesIO
from qgis.core import (QgsProject, QgsVectorLayer, QgsGeometry, 
                       QgsFeature, QgsMapSettings, QgsMapRendererCustomPainterJob,
                       QgsWkbTypes, QgsCoordinateTransform, QgsPointXY,
                       QgsCoordinateReferenceSystem, QgsRectangle)
from qgis.gui import QgsMapTool, QgsRubberBand
from qgis.utils import iface
from PyQt5.QtCore import Qt, QSize, QBuffer, QIODevice, QByteArray
from PyQt5.QtGui import QColor, QImage, QPainter, QPainterPath
from PyQt5.QtWidgets import (QAction, QDialog, QSpinBox, QPushButton, 
                             QFileDialog, QFormLayout, QDialogButtonBox, 
                             QLabel, QProgressDialog, QComboBox, QMessageBox,
                             QApplication)

# ======================================================
# CONSTANTS
# ======================================================
TILE_SIZE = 256
RENDER_SIZE = 384  # Render larger for meta-tiling (prevents label clipping)
WORLD_CIRCUMFERENCE = 40075016.686
ORIGIN_SHIFT = 20037508.342789244

# ======================================================
# 1. TILE MATH UTILITIES
# ======================================================
def lon_lat_to_meters(lon, lat):
    mx = lon * ORIGIN_SHIFT / 180.0
    my = math.log(math.tan((90 + lat) * math.pi / 360.0)) / (math.pi / 180.0)
    my = my * ORIGIN_SHIFT / 180.0
    return mx, my

def meters_to_tile(mx, my, zoom):
    resolution = WORLD_CIRCUMFERENCE / (TILE_SIZE * (2 ** zoom))
    px = (mx + ORIGIN_SHIFT) / resolution
    py = (ORIGIN_SHIFT - my) / resolution
    tx = int(px / TILE_SIZE)
    ty = int(py / TILE_SIZE)
    return tx, ty

def tile_to_extent(z, x, y):
    tile_size_meters = WORLD_CIRCUMFERENCE / (2 ** z)
    x_min = x * tile_size_meters - ORIGIN_SHIFT
    x_max = (x + 1) * tile_size_meters - ORIGIN_SHIFT
    y_max = ORIGIN_SHIFT - y * tile_size_meters
    y_min = ORIGIN_SHIFT - (y + 1) * tile_size_meters
    return QgsRectangle(x_min, y_min, x_max, y_max)

def tile_to_geometry(z, x, y):
    extent = tile_to_extent(z, x, y)
    return QgsGeometry.fromRect(extent)

def get_intersecting_tiles(polygon_geom, source_crs, zoom_min, zoom_max):
    web_mercator = QgsCoordinateReferenceSystem("EPSG:3857")
    transform = QgsCoordinateTransform(source_crs, web_mercator, QgsProject.instance())
    
    poly_3857 = QgsGeometry(polygon_geom)
    poly_3857.transform(transform)
    
    tiles = []
    bbox = poly_3857.boundingBox()
    
    for z in range(zoom_min, zoom_max + 1):
        x_min, y_min = meters_to_tile(bbox.xMinimum(), bbox.yMaximum(), z)
        x_max, y_max = meters_to_tile(bbox.xMaximum(), bbox.yMinimum(), z)
        
        max_tile = (2 ** z) - 1
        x_min = max(0, x_min)
        x_max = min(max_tile, x_max)
        y_min = max(0, y_min)
        y_max = min(max_tile, y_max)
        
        for x in range(x_min, x_max + 1):
            for y in range(y_min, y_max + 1):
                tile_geom = tile_to_geometry(z, x, y)
                if tile_geom.intersects(poly_3857):
                    tiles.append((z, x, y))
    
    return tiles, poly_3857

# ======================================================
# 2. MBTILES DATABASE HANDLER
# ======================================================
class MBTilesWriter:
    def __init__(self, path, name="Shaped Export", description="Generated by QGIS", 
                 tile_format="png", bounds=None, min_zoom=0, max_zoom=14):
        self.path = path
        self.conn = sqlite3.connect(path)
        self.cursor = self.conn.cursor()
        self._init_schema()
        self._write_metadata(name, description, tile_format, bounds, min_zoom, max_zoom)
    
    def _init_schema(self):
        self.cursor.execute("""
            CREATE TABLE IF NOT EXISTS tiles (
                zoom_level INTEGER,
                tile_column INTEGER,
                tile_row INTEGER,
                tile_data BLOB,
                PRIMARY KEY (zoom_level, tile_column, tile_row)
            )
        """)
        self.cursor.execute("""
            CREATE TABLE IF NOT EXISTS metadata (
                name TEXT PRIMARY KEY,
                value TEXT
            )
        """)
        self.conn.commit()
    
    def _write_metadata(self, name, description, tile_format, bounds, min_zoom, max_zoom):
        metadata = {
            'name': name,
            'type': 'baselayer',
            'version': '1.0',
            'description': description,
            'format': tile_format,
            'minzoom': str(min_zoom),
            'maxzoom': str(max_zoom)
        }
        if bounds:
            metadata['bounds'] = f"{bounds[0]},{bounds[1]},{bounds[2]},{bounds[3]}"
        
        for key, value in metadata.items():
            self.cursor.execute(
                "INSERT OR REPLACE INTO metadata (name, value) VALUES (?, ?)",
                (key, value)
            )
        self.conn.commit()
    
    def write_tile(self, z, x, y, image_data):
        tms_y = (2 ** z) - 1 - y
        self.cursor.execute(
            "INSERT OR REPLACE INTO tiles (zoom_level, tile_column, tile_row, tile_data) VALUES (?, ?, ?, ?)",
            (z, x, tms_y, image_data)
        )
    
    def commit(self):
        self.conn.commit()
    
    def close(self):
        self.conn.commit()
        self.cursor.execute("VACUUM")
        self.conn.close()

# ======================================================
# 3. TILE RENDERER - CLIPPING VERSION
# ======================================================
class ShapedTileRenderer:
    """
    Uses clipping approach instead of filling the inverse.
    
    Flow:
    1. Fill background with mask color
    2. Set clip path to polygon
    3. Render map (only renders within clip)
    """
    
    def __init__(self, polygon_geom_3857, mask_style=0):
        self.polygon = polygon_geom_3857
        self.mask_style = mask_style
        self.web_mercator = QgsCoordinateReferenceSystem("EPSG:3857")
        
    def render_tile(self, z, x, y, layers):
        extent = tile_to_extent(z, x, y)
        tile_geom = QgsGeometry.fromRect(extent)
        
        # Check if tile is fully inside polygon (no clipping needed)
        tile_fully_inside = self.polygon.contains(tile_geom)
        
        # Calculate expanded extent for meta-tiling
        buffer_ratio = (RENDER_SIZE - TILE_SIZE) / (2 * TILE_SIZE)
        expand_x = extent.width() * buffer_ratio
        expand_y = extent.height() * buffer_ratio
        render_extent = QgsRectangle(
            extent.xMinimum() - expand_x,
            extent.yMinimum() - expand_y,
            extent.xMaximum() + expand_x,
            extent.yMaximum() + expand_y
        )
        
        # Setup map settings
        settings = QgsMapSettings()
        settings.setOutputSize(QSize(RENDER_SIZE, RENDER_SIZE))
        settings.setExtent(render_extent)
        settings.setDestinationCrs(self.web_mercator)
        settings.setLayers(layers)
        settings.setFlag(QgsMapSettings.Antialiasing, True)
        settings.setFlag(QgsMapSettings.UseAdvancedEffects, True)
        
        # Create image with appropriate format
        if self.mask_style == 0:  # Transparent
            render_image = QImage(RENDER_SIZE, RENDER_SIZE, QImage.Format_ARGB32)
            render_image.fill(Qt.transparent)
        else:
            render_image = QImage(RENDER_SIZE, RENDER_SIZE, QImage.Format_RGB32)
            bg_color = QColor("white") if self.mask_style == 1 else QColor("black")
            render_image.fill(bg_color)
        
        painter = QPainter(render_image)
        painter.setRenderHint(QPainter.Antialiasing, True)
        
        # If tile is NOT fully inside, set clip path BEFORE rendering
        if not tile_fully_inside:
            clip_path = self._get_clip_path(render_extent)
            if clip_path:
                painter.setClipPath(clip_path)
        
        # Render map - with clipping, only pixels inside the path are drawn
        job = QgsMapRendererCustomPainterJob(settings, painter)
        job.start()
        job.waitForFinished()
        
        painter.end()
        
        # Crop to final tile size
        buffer_px = (RENDER_SIZE - TILE_SIZE) // 2
        final_image = render_image.copy(buffer_px, buffer_px, TILE_SIZE, TILE_SIZE)
        
        return final_image
    
    def _get_clip_path(self, extent):
        """Get the polygon clip path for this extent"""
        render_geom = QgsGeometry.fromRect(extent)
        clipped = self.polygon.intersection(render_geom)
        
        if clipped.isEmpty():
            # Completely outside - return None (nothing to render)
            return None
        
        return self._geometry_to_path(clipped, extent, RENDER_SIZE)
    
    def _geometry_to_path(self, geom, extent, image_size=TILE_SIZE):
        path = QPainterPath()
        
        x_scale = image_size / extent.width()
        y_scale = image_size / extent.height()
        
        def to_pixel(point):
            px = (point.x() - extent.xMinimum()) * x_scale
            py = (extent.yMaximum() - point.y()) * y_scale
            return px, py
        
        if geom.type() == QgsWkbTypes.PolygonGeometry:
            if geom.isMultipart():
                polygons = geom.asMultiPolygon()
            else:
                polygons = [geom.asPolygon()]
            
            for polygon in polygons:
                for ring_idx, ring in enumerate(polygon):
                    if len(ring) < 3:
                        continue
                    
                    px, py = to_pixel(ring[0])
                    path.moveTo(px, py)
                    
                    for point in ring[1:]:
                        px, py = to_pixel(point)
                        path.lineTo(px, py)
                    
                    path.closeSubpath()
        
        return path

# ======================================================
# 4. CONFIGURATION DIALOG
# ======================================================
class ShapedTileConfigDialog(QDialog):
    def __init__(self, polygon_geometry, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Shaped MBTiles (Clipping Version)")
        self.resize(400, 320)
        self.poly = polygon_geometry
        self.web_mercator = QgsCoordinateReferenceSystem("EPSG:3857")
        self.source_crs = QgsProject.instance().crs()
        
        layout = QFormLayout(self)
        
        info = QLabel("CLIPPING VERSION - Uses clip path instead of filling inverse.")
        info.setWordWrap(True)
        info.setStyleSheet("color: #cc6600; margin-bottom: 10px;")
        layout.addRow(info)
        
        self.min_zoom = QSpinBox()
        self.min_zoom.setRange(0, 22)
        self.min_zoom.setValue(10)
        self.min_zoom.valueChanged.connect(self.update_estimate)
        layout.addRow("Minimum Zoom:", self.min_zoom)
        
        self.max_zoom = QSpinBox()
        self.max_zoom.setRange(0, 22)
        self.max_zoom.setValue(14)
        self.max_zoom.valueChanged.connect(self.update_estimate)
        layout.addRow("Maximum Zoom:", self.max_zoom)
        
        self.color_select = QComboBox()
        self.color_select.addItems([
            "Transparent Outside (PNG)", 
            "White Outside (JPG/PNG)", 
            "Black Outside (JPG/PNG)"
        ])
        layout.addRow("Mask Style:", self.color_select)

        self.file_btn = QPushButton("Select Output File...")
        self.file_btn.clicked.connect(self.select_file)
        self.output_path = ""
        self.file_label = QLabel("No file selected")
        self.file_label.setWordWrap(True)
        layout.addRow(self.file_btn, self.file_label)
        
        self.estimate_label = QLabel("Calculating...")
        self.estimate_label.setStyleSheet("font-weight: bold;")
        layout.addRow("Tiles to Generate:", self.estimate_label)
        
        self.buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        layout.addRow(self.buttons)
        
        self.update_estimate()

    def select_file(self):
        f, _ = QFileDialog.getSaveFileName(self, "Save MBTiles", "", "MBTiles (*.mbtiles)")
        if f:
            if not f.endswith('.mbtiles'):
                f += '.mbtiles'
            self.output_path = f
            self.file_label.setText(os.path.basename(f))

    def update_estimate(self):
        min_z = self.min_zoom.value()
        max_z = self.max_zoom.value()
        
        if min_z > max_z:
            self.estimate_label.setText("Error: Min > Max")
            self.estimate_label.setStyleSheet("color: red;")
            return

        tiles, _ = get_intersecting_tiles(self.poly, self.source_crs, min_z, max_z)
        actual_tiles = len(tiles)
        
        if actual_tiles < 50000:
            self.estimate_label.setStyleSheet("color: green; font-weight: bold;")
        elif actual_tiles < 500000:
            self.estimate_label.setStyleSheet("color: orange; font-weight: bold;")
        else:
            self.estimate_label.setStyleSheet("color: red; font-weight: bold;")
        
        self.estimate_label.setText(f"{actual_tiles:,} tiles")
        
        self.tile_count_cache = actual_tiles
        self.tiles_cache = tiles

    def get_settings(self):
        tiles, poly_3857 = get_intersecting_tiles(
            self.poly, self.source_crs, 
            self.min_zoom.value(), self.max_zoom.value()
        )
        return {
            'ZOOM_MIN': self.min_zoom.value(),
            'ZOOM_MAX': self.max_zoom.value(),
            'MASK_STYLE': self.color_select.currentIndex(),
            'OUTPUT_FILE': self.output_path,
            'TILES': tiles,
            'POLYGON_3857': poly_3857
        }

# ======================================================
# 5. DRAW TOOL
# ======================================================
class ShapedMBTilesTool(QgsMapTool):
    def __init__(self, canvas):
        self.canvas = canvas
        QgsMapTool.__init__(self, self.canvas)
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rubberBand.setColor(QColor(200, 150, 50, 180))  # Orange to distinguish from other version
        self.rubberBand.setWidth(3)
        self.points = []

    def canvasPressEvent(self, e):
        if e.button() == Qt.LeftButton:
            point = self.toMapCoordinates(e.pos())
            self.points.append(point)
            self.rubberBand.addPoint(point)
        elif e.button() == Qt.RightButton:
            if len(self.points) > 2:
                self.finish_drawing()
            self.reset()

    def reset(self):
        self.points = []
        self.rubberBand.reset(QgsWkbTypes.PolygonGeometry)
        self.canvas.unsetMapTool(self)

    def finish_drawing(self):
        poly_geom = QgsGeometry.fromPolygonXY([self.points])
        
        dlg = ShapedTileConfigDialog(poly_geom, iface.mainWindow())
        if dlg.exec_() != QDialog.Accepted:
            return
        
        settings = dlg.get_settings()
        
        if not settings['OUTPUT_FILE']:
            QMessageBox.warning(None, "Error", "Please select an output file.")
            return
        
        self.generate_tiles(settings)

    def generate_tiles(self, settings):
        tiles = settings['TILES']
        polygon = settings['POLYGON_3857']
        output_path = settings['OUTPUT_FILE']
        mask_style = settings['MASK_STYLE']
        
        progress = QProgressDialog("Generating (Clipping Version)...", "Cancel", 0, len(tiles), iface.mainWindow())
        progress.setWindowModality(Qt.WindowModal)
        progress.setMinimumDuration(0)
        progress.setValue(0)
        
        layers = [l for l in iface.mapCanvas().layers() if l.isValid()]
        tile_format = "png" if mask_style == 0 else "jpg"
        
        wgs84 = QgsCoordinateReferenceSystem("EPSG:4326")
        web_mercator = QgsCoordinateReferenceSystem("EPSG:3857")
        to_wgs84 = QgsCoordinateTransform(web_mercator, wgs84, QgsProject.instance())
        bbox_wgs84 = to_wgs84.transformBoundingBox(polygon.boundingBox())
        bounds = (bbox_wgs84.xMinimum(), bbox_wgs84.yMinimum(), 
                  bbox_wgs84.xMaximum(), bbox_wgs84.yMaximum())
        
        writer = MBTilesWriter(
            output_path,
            name="Shaped Export (Clipping)",
            description="Generated with clipping approach",
            tile_format=tile_format,
            bounds=bounds,
            min_zoom=settings['ZOOM_MIN'],
            max_zoom=settings['ZOOM_MAX']
        )
        
        renderer = ShapedTileRenderer(polygon, mask_style)
        
        try:
            for i, (z, x, y) in enumerate(tiles):
                if progress.wasCanceled():
                    break
                
                image = renderer.render_tile(z, x, y, layers)
                
                buffer = QBuffer()
                buffer.open(QIODevice.WriteOnly)
                
                if mask_style == 0:
                    image.save(buffer, "PNG")
                else:
                    image.save(buffer, "JPEG", 85)
                
                writer.write_tile(z, x, y, bytes(buffer.data()))
                
                progress.setValue(i + 1)
                progress.setLabelText(f"Tile {i+1}/{len(tiles)} (Z{z})")
                QApplication.processEvents()
            
            writer.close()
            
            if not progress.wasCanceled():
                iface.messageBar().pushMessage(
                    "Success", 
                    f"Generated {len(tiles)} tiles (clipping version)", 
                    level=3, duration=5
                )
        except Exception as e:
            QMessageBox.critical(None, "Error", f"Generation failed: {str(e)}")
        finally:
            progress.close()

# ======================================================
# 6. LAUNCH
# ======================================================
def activate_shaped_tool():
    tool = ShapedMBTilesTool(iface.mapCanvas())
    iface.mapCanvas().setMapTool(tool)